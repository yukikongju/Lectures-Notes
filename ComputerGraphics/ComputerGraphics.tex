\documentclass{article}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{parskip}
\usepackage{textgreek}
\begin{document}
\title{Lecture Notes for CMU 15-462: Computer Graphics}
\author{Emulie Chhor}
\maketitle

\section{Introduction}

Courses Notes for CMU 15-462: Computer Graphics by Keenan Crane

\section{Course Overview}

\textbf{Overview}

\begin{enumerate}
    \item What is Computer Graphics
    \item What do we learn in Computer Graphics
    \item What is Modelization
    \item What is Rendering
    \item Projects throughout the course
\end{enumerate}

\subsection{What is Computer Graphics}

The goal of computer graphics is to simulate sensory information by
turning digital information into sensory stimuli (visual, sound, texture).
Its "inverse" would be the field of computer vision, whose goal is to
translate sensory information in our environment into digital information.

\subsection{What do we learn in Computer Graphics}

There are two phases to learning computer graphics:
\begin{enumerate}
    \item Theory: What are the techniques used to simulate sensory stimuli
    \item Systems: How can we simulate those stimuli efficiently
\end{enumerate}

\textbf{Theory}

\begin{enumerate}
    \item Representation: How do we encode shape and motion?
    \item Sampling and Aliasing: How can we acquire and reproduce signal
    \item Numerical Methods: How can we modify signal
    \item Radiometry and Light Transport: How can we reproduce light
	behavior
    \item Perception: What can we learn from psychology and physiology
	to enhance human perception
\end{enumerate}

\textbf{Systems}

\begin{enumerate}
    \item Parallel and Heterogenous Processing
    \item Graphics-Specific Programming Languages
\end{enumerate}

\subsection{What is Modelization}

The first concept to understand in computer graphics is that we can
produce simuli in two steps:
\begin{enumerate}
    \item Modelization: How can we describe object to a computer
    \item Rasterization: How will the computer translate our model into
	sensory stimuli
\end{enumerate}

Usually, modelization is done by
\begin{enumerate}
    \item Listing a bunch of points
    \item Linking these points with a list of edges
\end{enumerate}

However, we often have to perform some transformations to accurately
represent the object. For instance, we need to find a way to represent
3D object onto a 2D shape.

\textbf{How to convert 3D points into 2D shapes}

One solution is to use perspective to our advantage. We know that object
further from us are smaller, so we can use the "pinhole camera" from
optical physics to realize that we have rectangular triangle, which
allow us to use pythagoras to form a ration between the original points
onto our 2D shape. If we have a 3D point (x,y,z) that we want to translate
onto a 2D shape (u,v), we
\begin{enumerate}
    \item substract the camera from the 3D point
    \item Divide (x,y) by z to get our 2D point (u,v)
\end{enumerate}

\subsection{What is Rendering}

To display our points on the computer, we first have to understand how
the computer screen works. A computer screen is made of pixels, which
are little square that contains a value which tells us how much green,
red and blue should be in the square.

Often, we talk about raster display because we take a continuous object
and represent it with a discrete mapping (pixels grid)

\textbf{Which Rasterization Techniques to use: diamond rule}

Since our shapes aren't alway rectangular, we must decide which pixels
to turn on and off. There exist a bunch of rasterization techniques,
but we often make up our own based on our needs:
\begin{enumerate}
    \item Turn on all pixels that the vector touches
    \item Diamond Rules: Turn pixel only if it passes through the diamond
	shape inside the pixel
\end{enumerate}

\textbf{How to color the pixel}

Like with rasterization, there are several ways to color each pixel,
but we often like to color it using the ratio of the vector inside the
pixel: the more a vector is inside a pixel, the more we make the color
thicker

\textbf{How does the computer find vector: incremental rasterization}

A naive solution to find which pixels to color would be to check each
pixel individually, which takes $O(n^2)$ for O(n) pixels. A better method
would be to use incremental rasterization. We

\begin{enumerate}
    \item Calculate the slope of the line and add it to the y-value to
	find the pixels inside the x-range of the vector
    \item Compute the pixel value
    \item Draw
\end{enumerate}

\subsection{Projects throughout the course}

The course consists of building our own library
\begin{enumerate}
    \item Rasterization
    \item Geometric Modeling
    \item Photorealistic Rendering
    \item Motion and Animation
\end{enumerate}

\section{Linear Algebra}

NEXT

\section{Vector Calculus}
\section{Drawing a Triangle and an Intro to Sampling}
\section{Spatial Transformations}
\section{3D Rotations and Complex Representations}
\section{Perspective Projection and Texture Mapping}
\section{Depth and Transparency}
\section{Introduction to Geometry}
\section{Meshes and Manifolds}
\section{Digital Geometry Processing}
\section{Geometric Queries}
\section{Spatial Data Structures}
\section{Color}
\section{Radiometry}
\section{The Rendering Equation}
\section{Numerical Integration}
\section{Monte Carlo Rendering}
\section{Variance Reduction}
\section{Introduction to Animation}
\section{Dynamics and Time Integration}
\section{Optimization}
\section{Physically Based Animation and PDEs}

\end{document}
\end{article}
